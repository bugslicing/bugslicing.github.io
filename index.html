<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Creating Bug Slicings : Techniques and examples">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Creating Bug Slicings</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/bugslicing">View on GitHub</a>

          <h1 id="project_title">Bug Slicings</h1>
          <h2 id="project_tagline">Techniques and examples</h2>

        </header>
    </div>

    <!-- MAIN CONTENT -->

    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>
    <a name="welcome-to-github-pages" class="anchor"
    href="#welcome-to-github-pages"><span class="octicon
    octicon-link"></span></a>What are bug slicings?</h3> 
<p>The way a programmer perceives and understands software source
      code that result in bugs can be systematically analyzed. We
      create a technique called <b>bug slicings</b>, generated from reports
      in bug trackers to assess programmers' common misconceptions. A
      bug slicing is a question about a snippet of code capturing a bug,
      generated by permuting compiler's parse tree. Bug slicings look
      similar but may have different output. They can help us to
      carefully separate the minimum set of conditions that lead to
      programmers' misconception.</p>

      <h4>An Example of Bug Slicing</h4>
<pre><code>    (a) Python:              (b) C:
1. while i<=100:   1. if((err=SSLHashSHA1.update(&hashCtx,&signedParams))!=0)
2.    i += 1       2.    goto fail;
3.    j += 1       3.    goto fail;
</code></pre>
      <h7 align="center">Figure 1: An example of source code
      containing a bug.</h7>

<p>An example bug containing a cryptographic issue is shown in Figure
      1(b). In Python, the relative indentation indicates nested
      blocks. However, in C and many other languages, indentation does
      not have any semantic meaning. In Figure 1(a), i and j have the
      same amount of relative indentation, therefore, they are
      increased together in each iteration. In Figure 1(b),
      programmers assume the same code behavior occurs due to the
      clues given by indentation. However, C does not obey
      indentation. Figure 1(b) is in fact a recent <a
      href="http://www.theregister.co.uk/2014/02/25/apple_mac_os_x_10_9_2_ssl/">Mac
      security bug</a> in C which uses indentation in a similar
      way. The second goto statement will always be executed
      regardless of the if statement result. As a result, a crucial
      cryptographic signature check in the code path is then skipped
      over, resulting in a severe security vulnerability.</p> 

<h4>
<a name="designer-templates" class="anchor"
href="#designer-templates"><span class="octicon
octicon-link"></span></a>Syntactic Errors</h4> 

<p>To analyze this bug, we first hypothesize that the root cause is a
combination of if statement and indentation. To eliminate any
potential cognitive confusion about the if condition and goto
statement in Figure 1(b), we replace them with the simplest
assignments: <code>1. a=5; 2. b=6; 3. c=7;</code>. We then tweak the original code
snippet and present the results to a developer as several bug
slicings:</p>

<pre><code>    (a)           (b)         (c)            (d)            (e)
1. a=5;     1. if(a!=0)    1. if(a==1)    1. if(a==1)    1. if(a==1)
2.  b=6;    2.   b=6;      2.   b=6;      2. b=6;        2. b=6;
3.  c=7;    3.   c=7;      3. c=7;        3. c=7;        3.   c=7;
</code></pre>
<h7 align="center">Figure 2: Syntactic bug slicings of Figure 1. (a)
tests whether a programmer misunderstands the the syntactic meaning of
C's indentation; (b) tests the programmer's understanding with the if
statement; (c) â€“ (d) test the programmer's knowledge about the
combinations of the same if statement with different indentation
levels.</h7>

<p>We generate these bug slicings by first generating the parse tree
of the original code as a compiler does. We then permute the tree to
get different slicings as above.</p> 

<h4>
<a name="rather-drive-stick" class="anchor"
href="#rather-drive-stick"><span class="octicon
octicon-link"></span></a>Semantic Errors</h4> 

<p>In addition to the syntactic errors above, the bug in Figure 1 also
contains semantic errors. In the assignment of the if statement in
Figure 1(b), even the variable err gets assigned value 0, indicating
no error in function <code>SSLHashSHA1.update()</code>, the program
execution will always goto fail, implied by the label
<code>fail</code> that an error has occurred. As the result, the developers
assume an error will be returned but, in fact, it is the opposite
status. The following bug slicings are generated to analyze this
semantic error.</p>  

<pre><code>      (a)              (b)               (c)                 (d)
1. if(err!=0)    1. if(err!=0)      1. if(err==0)       1. if(err==0)
2.  goto fail;   2.  goto fail;     2.  goto fail;      2.  goto success;
3.  goto fail;   3.  goto success;  3.  goto success;   3.  goto success;
</code></pre>
<h7 align="center">Figure 3: Semantic bug slicings of Figure 1.</h7>

<p>These examples are simplified for discussion purposes. In practice,
there are much more complex bugs such as those involving buffer
overflows, variable shadowing, scoping rules for closures,
time-of-check-to-time-of-use, integer overflows, and the more recent
heartbleed. Through bug slicings, we can tease out where the problem
is, identify the minimum set of conditions that lead to programmers'
misconception, and understand the pattern of a specific bug. Such an
understanding can be applied to more general bugs.</p> 


      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
